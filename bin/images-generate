#!/usr/bin/env node

const util = require('util')
const path = require('path')
const fs = require('fs')
const childProcess = require('child_process')

const exec = util.promisify(childProcess.exec)
const readFile = util.promisify(fs.readFile)
const writeFile = util.promisify(fs.writeFile)

const glob = require('glob-promise')

const cssFile = './bin/styles/mermaid-sequence.css'

const checkGenerationTime = (source, generated) => {
  const sourceStat = fs.statSync(source)
  const generatedStats = generated.map(genPath => {
    try {
      return fs.statSync(genPath)
    } catch (e) {
      return null
    }
  })
    .filter(genStat => {
      if (genStat === null) {
        return false
      }
      return genStat.mtime >= sourceStat.mtime
    })

  return !!generatedStats.length
}

const generateMermaidImages = async (dir) => {
  const cssFileContents = fs.readFileSync(cssFile).toString()
  const styleDef = `<defs>
  <style type="text/css">
  ${cssFileContents}
  </style>
</defs>`

  const mmdFiles = await glob(`${dir}/**/*.mmd`)

  mmdFiles.forEach(filePath => {
    readFile(filePath)
      .then(fileContents => {
        const settings = {
          width: 1200,
          height: 1200
        }
        const fileChunks = fileContents.toString().split('\n').filter(chunk => chunk.startsWith('%%'))
        fileChunks.forEach(chunk => {
          chunk = chunk.replace(/%%\s*/, '')
          const setting = chunk.split(/\s*:\s*/)
          if (setting.length === 2) {
            settings[setting[0]] = setting[1]
          }
        })
        const pngPath = filePath.replace(/\.mmd$/, '.png')
        const svgPath = filePath.replace(/\.mmd$/, '.svg')
        const alreadyGenerated = checkGenerationTime(filePath, [pngPath, svgPath])
        if (alreadyGenerated) {
          return
        }
        process.stdout.write(`Processing ${filePath}\n`)

        exec(`mmdc -i ${filePath} -o ${pngPath} --cssFile ${cssFile} --height ${settings.height} --width ${settings.width}`)
        exec(`mmdc -i ${filePath} -o ${svgPath} --cssFile ${cssFile} --height ${settings.height} --width ${settings.width}`)
          .then(() => {
            readFile(svgPath)
              .then(svgFile => {
                let svgFileContents = svgFile.toString().replace(/<\/style><g>/, (m) => {
                  return `</style>${styleDef}<g>`
                })
                writeFile(svgPath, svgFileContents)
                  .then(() => {})
              })
          })
      })
  })
}

const generateGraphvizImages = async (dir) => {
  const dotFiles = await glob(`${dir}/**/*.dot`)
  dotFiles.forEach(filePath => {
    const pngPath = filePath.replace(/\.dot$/, '.png')
    const svgPath = filePath.replace(/\.dot$/, '.svg')
    const alreadyGenerated = checkGenerationTime(filePath, [pngPath, svgPath])
    if (alreadyGenerated) {
      return
    }
    process.stdout.write(`Processing ${filePath}\n`)

    exec(`dot -Tpng ${filePath} -o ${pngPath}`)
    exec(`dot -Tsvg ${filePath} -o ${svgPath}`)
  })
}

const generateImages = async () => {
  await generateMermaidImages(path.resolve(__dirname, '..', 'documentation'))
  await generateGraphvizImages(path.resolve(__dirname, '..', 'documentation'))
}

generateImages()
