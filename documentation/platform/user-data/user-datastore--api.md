# Datastore API

## Introduction

Services written & deployed with FormBuilder require a component to store data submitted by their users in a secure way. We have agreed a suitable implementation with the Information Security team, discussed in detail in "Runner / User data store Threats & Mitigations".

This document summarises requirements for the User Data Store component & knock-on implications for the other components affected - the Runner & Publisher. 


## System Context

TODO: Insert image

## API

### No Ingress, HTTPS-only

Ideally this would be achieved with a Service Mesh (e.g. https://istio.io) but this is not provided by the Cloud Platform at the time of writing, nor is it currently on their near-term roadmap.
Therefore we’ll experiment with an internal load balancer model (see https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer and https://kubernetes.io/docs/concepts/services-networking/service/#ssl-support-on-aws )

*UPDATE 10/10/2018*  
*Cloud Platform team are now discouraging the use of Kubernetes services of type ‘LoadBalancer’, have accepted that secure internal comms is a requirement, and now have a card for this on their roadmap - as a result, considering we are not planning to hosting any live public-facign services in the immediate future, we’ll hold on for whatever solution they end up with.*

### RDS Postgres Database

DynamoDB may suit the use case better in the long-term, but is not yet supported by Cloud Platforms. 
Postgres supports JSON columns & infrastructure-level encryption-at-rest, so is fine for now.

### JWT authentication

Each request will be timestamped and signed using a per-service serviceToken (generated by Publisher and injected into the service’s Runner as an environment variable).


## Runner

At the start of each request, the Runner must:

- Read the userID from the users’ cookie

  If not present, generate a userID and store it in the cookie

- Read the userToken from the users’ cookie

  If not present, generate a 256-bit random hex string and store it as userToken in the cookie

- Read the Digest from the user’s cookie

  The Digest MUST equal the SHA-256 Hash of userID + userToken + serviceToken

  If it does not, the runner must return HTTP status 400 (Bad Request) and cease any further processing

- Request the user data from the Datastore API

  The URL will be of the form `/service/(service-slug)/user/(userId).json`

  - The request must be signed using JWT with the service’s serviceToken (this will be injected into the Runner’s container as an environment variable called SERVICE_TOKEN, by Publisher). Suggested algorithm: HMAC with SHA-256
  - Signing options should include iat: (current timestamp)to allow a time-limit and mitigate against replay attacks
  - The resulting token must be passed as a header called x-access-token 


- If the data exists, the response will be a JSON packet of the form:

  ```json
  {
    "timestamp": "(ISO8601-formatted datetime of last update)",
    "payload": "(user data encrypted with userToken)"
  }
  ```

  The Runner can then decrypt the payload with the userToken and use it as required

- If the data does not exist, the response will have a 404 status and an empty body
  - If the token is not present, the response will be 401 Unauthorised
  - If the token is not valid, the response will be 403 Forbidden

To store data in the user data store, the Runner must:

- Encrypt the JSON packet containing the data to be stored with the AES-256 algorithm, using the userToken as the key


- POST the payload to /service/(service slug)/user/(userId).json

The body must be of the form:

```json
{
  "payload": "(encrypted data)"
}
```

The request must be signed using JWT with the service’s serviceToken (this will be injected into the Runner’s container as an environment variable called SERVICE_TOKEN, by Publisher) Signing options should include `iat: (current timestamp)` to allow a time-limit and mitigate against replay attacks
The resulting token must be passed as a header called `x-access-token`

- If the request was successful, the response status will be 201 Created (if no matching record previously existed) or 204 No Content (if a matching record did already exist)
  - If the token is not present, the response will be 401 Unauthorised
  - If the token is not valid, the response will be 403 Forbidden



## Publisher

Publisher needs:

- A field adding to the Service record to store the service token
- Auto-generation of the service token on creation
- A button in the UI for generating a new service token
- UI to allow inspection of the service token (treated like a password field - i.e. obfuscated by default, only revealed when explicitly needed)
- SERVICE_TOKEN to be injected as an environment variable when deploying a service


